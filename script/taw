#!/usr/bin/env perl
# vim: ts=4:sw=4:expandtab :

use strict;
use Getopt::Long;
use Pod::Usage;
use File::Temp qw(tempfile);
use JSON;

# Option state

my $flag_output_json   = 0;
my $flag_output_csv    = 0;
my $flag_output_pretty = 0;
my $flag_output_raw    = 0;
my $flag_no_header     = 0;
my $flag_help          = 0;
my $flag_verbose       = 0;
my $flag_man           = 0;
my $debug = 0;
my $debug_leave_file = 0;
my $param_region;

# Constants
our %region_name_2_region_str = (
    "us-east-1"      => "virginia",
    "us-west-1"      => "california",
    "us-west-2"      => "oregon",
    "sa-east-1"      => "sanpaulo",
    "eu-west-1"      => "ireland",
    "eu-central-1"   => "frankfurt",
    "ap-southeast-1" => "singapore",
    "ap-southeast-2" => "sydney",
    "ap-northeast-1" => "tokyo",
    "ap-northeast-2" => "seoul",
    "ap-south-1"     => "mumbai"
);

our %instance_type_name_2_instance_type = (
    "t2.nano"        => {"vcpu" =>   1, "mem" =>  0.5, "desc" =>  "3 credit minutes/hour, EBS backend"},
    "t2.micro"       => {"vcpu" =>   1, "mem" =>    1, "desc" =>  "6 credit minutes/hour, EBS backend"},
    "t2.small"       => {"vcpu" =>   1, "mem" =>    2, "desc" =>  "12 credit minutes/hour, EBS backend"},
    "t2.medium"      => {"vcpu" =>   2, "mem" =>    4, "desc" =>  "24 credit minutes/hour, EBS backend"},
    "t2.large"       => {"vcpu" =>   2, "mem" =>    8, "desc" =>  "36 credit minutes/hour, EBS backend"},
    "m4.large"       => {"vcpu" =>   2, "mem" =>    8, "desc" =>  "450Mbps EBS, EBS backend"},
    "m4.xlarge"      => {"vcpu" =>   4, "mem" =>   16, "desc" =>  "750Mbps EBS, EBS backend"},
    "m4.2xlarge"     => {"vcpu" =>   8, "mem" =>   32, "desc" =>  "1Gbps EBS, EBS backend"},
    "m4.4xlarge"     => {"vcpu" =>  16, "mem" =>   64, "desc" =>  "2Gbps EBS, EBS backend"},
    "m4.10xlarge"    => {"vcpu" =>  40, "mem" =>  160, "desc" =>  "4Gbps EBS, EBS backend"},
    "m3.medium"      => {"vcpu" =>   1, "mem" => 3.75, "desc" =>  "1x4GB SSD"},
    "m3.large"       => {"vcpu" =>   2, "mem" =>  7.5, "desc" =>  "1x32GB SSD"},
    "m3.xlarge"      => {"vcpu" =>   4, "mem" =>   15, "desc" =>  "2x40GB SSD"},
    "m3.2xlarge"     => {"vcpu" =>   8, "mem" =>   30, "desc" =>  "2x80GB SSD"},
    "c4.large"       => {"vcpu" =>   2, "mem" => 3.75, "desc" =>  "500Mbps EBS, EBS backend"},
    "c4.xlarge"      => {"vcpu" =>   4, "mem" =>  7.5, "desc" =>  "750Mbps EBS, EBS backend"},
    "c4.2xlarge"     => {"vcpu" =>   8, "mem" =>   15, "desc" =>  "1Gbps EBS, EBS backend"},
    "c4.4xlarge"     => {"vcpu" =>  16, "mem" =>   30, "desc" =>  "2Gbps EBS, EBS backend"},
    "c4.8xlarge"     => {"vcpu" =>  32, "mem" =>   60, "desc" =>  "4Gbps EBS, EBS backend"},
    "c3.large"       => {"vcpu" =>   2, "mem" => 3.75, "desc" =>  "2x16GB SSD"},
    "c3.xlarge"      => {"vcpu" =>   4, "mem" =>  7.5, "desc" =>  "2x40GB SSD"},
    "c3.2xlarge"     => {"vcpu" =>   8, "mem" =>   15, "desc" =>  "2x80GB SSD"},
    "c3.4xlarge"     => {"vcpu" =>  16, "mem" =>   30, "desc" =>  "2x160GB SSD"},
    "c3.8xlarge"     => {"vcpu" =>  32, "mem" =>   60, "desc" =>  "2x320GB SSD"},
    "x1.32xlarge"    => {"vcpu" => 128, "mem" => 1952, "desc" =>  "2x1920GB SSD, 10Gbps EBS"},
    "r3.large"       => {"vcpu" =>   2, "mem" => 15.25, "desc" =>  "1x32GB SSD"},
    "r3.xlarge"      => {"vcpu" =>   4, "mem" => 30.5, "desc" =>  "1x80GB SSD"},
    "r3.2xlarge"     => {"vcpu" =>   8, "mem" =>   61, "desc" =>  "1x160GB SSD"},
    "r3.4xlarge"     => {"vcpu" =>  16, "mem" =>  122, "desc" =>  "1x320GB SSD"},
    "r3.8xlarge"     => {"vcpu" =>  32, "mem" =>  244, "desc" =>  "2x320GB SSD"},
    "g2.2xlarge"     => {"vcpu" =>   8, "mem" =>   15, "desc" =>  "1 GPU (Kepler, GK104), 1x60GB SSD"},
    "g2.8xlarge"     => {"vcpu" =>  32, "mem" =>   60, "desc" =>  "4 GPUs (Kepler, GK104), 2x120GB SSD"},
    "i2.xlarge"      => {"vcpu" =>   4, "mem" => 30.5, "desc" =>  "1x800GB SSD"},
    "i2.2xlarge"     => {"vcpu" =>   8, "mem" =>   61, "desc" =>  "2x800GB SSD"},
    "i2.4xlarge"     => {"vcpu" =>  16, "mem" =>  122, "desc" =>  "4x800GB SSD"},
    "i2.8xlarge"     => {"vcpu" =>  32, "mem" =>  244, "desc" =>  "8x800GB SSD"},
    "d2.xlarge"      => {"vcpu" =>   4, "mem" => 30.5, "desc" =>  "3x2TB HDD"},
    "d2.2xlarge"     => {"vcpu" =>   8, "mem" =>   61, "desc" =>  "6x2TB HDD"},
    "d2.4xlarge"     => {"vcpu" =>  16, "mem" =>  122, "desc" =>  "12x2TB HDD"},
    "d2.8xlarge"     => {"vcpu" =>  36, "mem" =>  244, "desc" =>  "24x2TB HDD"}
);

our @trusted_ami_owners = (
    'amazon',         # Amazon, of course
    '309956199498',   # RedHat
    '099720109477'    # Ubuntu
);

# Prototypes
sub cmd_cache_image();
sub cmd_create(@);
sub cmd_fw(@);
sub cmd_help($);
sub cmd_images();
sub cmd_list($);
sub cmd_mosh($);
sub cmd_scp($$);
sub cmd_setdns($$);
sub cmd_show($);
sub cmd_ssh($$);
sub cmd_update(@);
sub convert_region_nick_name($);
sub create_new_instance($$$$$);
sub ensure_command($);
sub error_if_jq_result_is_too_small(@);
sub exec_and_print_in_format($$$$);
sub exec_and_return_array($$);
sub exec_and_exit_if_error($$);
sub save_to_tmp_file_and_return_file_name(@);
sub get_effective_region_name();
sub get_image_info_cache_file_name();
sub get_instance_id_from_name($);
sub get_security_group_id_from_name($);
sub is_region_name_sane($);
sub is_valid_cidr($);
sub is_valid_private_cidr($);
sub normalize_cidr($);
sub print_valid_cidr_examples();
sub save_to_tmp_file_and_return_file_name(@);

# Program starts here
GetOptions(
    "json"       => \$flag_output_json,
    "csv"        => \$flag_output_csv,
    "pretty|p"   => \$flag_output_pretty,
    "raw"        => \$flag_output_raw,
    "noheader|n" => \$flag_no_header,
    "verbose"    => \$flag_verbose,
    "help"       => \$flag_help,
    "man"        => \$flag_man,
    "region=s"   => \$param_region,
    "debug"      => \$debug,
    "leavefile"  => \$debug_leave_file
);

pod2usage(1) if $flag_help;
pod2usage(-verbose => 2) if $flag_man; 

if(defined $param_region) {
    $param_region = convert_region_nick_name($param_region);
    unless(is_region_name_sane($param_region)) {
        print STDERR "ERROR: region name '" . $param_region . "' is unknown.\n";
        exit 1;
    }
    $ENV{'AWS_DEFAULT_REGION'} = $param_region;
    print STDERR "AWS_DEFAULT_REGION is set to '$param_region'\n" if($debug);
}
unless($flag_output_raw || $flag_output_csv || $flag_output_json || $flag_output_pretty) {
    $flag_output_pretty = 1;
}

my $subcommand = shift;
cmd_help(undef) unless(defined $subcommand);
if($subcommand =~ m|^help$|i) {
    my $subsubcmd = shift;
    cmd_help($subsubcmd);
}
ensure_command('aws');
ensure_command('jq');
ensure_command('csvgrep');
ensure_command('csvlook');
if($subcommand =~ m|^show$|i) {
    my $type = shift;
    cmd_show($type);
}
if($subcommand =~ m|^list$|i) {
    my $subsubcmd = shift;
    cmd_list($subsubcmd);
}
cmd_images() if($subcommand =~ m|^images?$|i);
if($subcommand =~ m|^(r?ssh)$|i) {
    my $ssh_cmd_name = $1;
    my $hostname = shift;
    cmd_ssh($hostname, $ssh_cmd_name);
}
if($subcommand =~ m|^scp$|i) {
    my $src = shift;
    my $dest = shift;
    cmd_scp($src, $dest);
}
if($subcommand =~ m|^mosh$|i) {
    my $hostname = shift;
    cmd_mosh($hostname);
}
if($subcommand =~ m|^setdns$|i) {
    my $hostname = shift;
    my $domainname = shift;
    cmd_setdns($hostname, $domainname);
}
if($subcommand =~ m|^create$|i) {
    my @subcmds = @ARGV;
    cmd_create(@subcmds);
}

if($subcommand =~ m|^fw$|i) {
    my @subcmds = @ARGV;
    cmd_fw(@subcmds);
}
if($subcommand =~ m|^update$|i) {
    my @subcmds = @ARGV;
    cmd_update(@subcmds);
}

print STDERR "Unknown Subcommand '$subcommand'.\n";
print STDERR "Type 'taw help' to list the available subcommands.\n";
exit 1;

sub cmd_help($)
{
    my $subcommand = shift;
    unless(defined $subcommand) {
        print STDERR "Usage: taw <subcommand> [options..] [arguments..]\n\n";
        print STDERR "Subcommands:\n";
        print STDERR "\thelp\tthis message\n";
        print STDERR "\tlist\tlist various info (eg, instances)\n";
        print STDERR "\tfw\tshow/modify firewall rules\n";
        print STDERR "\tssh\tssh to a specified instance\n";
        print STDERR "\trssh\trssh to a specified instance\n";
        print STDERR "\tscp\tscp to a specified instance\n";
        print STDERR "\tmosh\tmosh to a specified instance\n";
        print STDERR "\tsetdns\tset an A record to DNS (hosted by Route 53)\n";
        print STDERR "\timages\tlist the images\n";
        print STDERR "\tcreate\tcreate something such as a new instance\n";
        print STDERR "\tshow\tshow various info (eg, the region names)\n";
        print STDERR "\nGlobal options:\n";
        print STDERR "\t--debug\tenable debugging. (may be helpful when debugging)\n";
        print STDERR "\t--region\tspecify the region to work with\n";
        exit 0;
    }
    if($subcommand =~ m|^list$|i) {
        print STDERR "Usage: taw list [object] [options..]\n\n";
        print STDERR "Available objects are:\n";
        print STDERR "\tinstances\tinstances. this is the default.\n";
        print STDERR "\tvpc\tVPCs\n";
        print STDERR "\n";
        print STDERR "Options:\n";
        print STDERR "\t-csv\toutput in CSV\n";
        print STDERR "\t-v\tverbose output\n";
        print STDERR "\t-n\tno header (works only when -csv is given)\n";
        print STDERR "\t-json\toutput in JSON\n";
        print STDERR "\t-pretty\toutput in pretty table (may need a wide screen)\n";
        exit 0;
    }
    if($subcommand =~ m|^create$|i) {
        print STDERR "Usage: taw create <target>\n\n";
        print STDERR "Create a new instance:\n";
        print STDERR "\ttaw create instance <name> <ami-id/quickimage-name> <key-name> <subnet> <security-group> [options...] [-- additional options for aws ec2 run-instances]\n\n";
        print STDERR "Example:\n";
        print STDERR "\ttaw create instance web1 ami-0123abcd mysshkey default\n";
        exit 0;
    }
    if($subcommand =~ m|^(r?ssh)$|i) {
        my $cmd_name = $1;
        print STDERR "Usage: taw $cmd_name <name> [options...] [-- options for SSH]\n\n";
        print STDERR "Example:\n";
        print STDERR "\ttaw $cmd_name foo --region=california -- -l myuser -I ~/.ssh/mykey.pem\n";
        exit 0;
    }
    if($subcommand =~ m|^mosh$|i) {
        print STDERR "Usage: taw mosh <name> [options...] [-- options for mosh]\n\n";
        print STDERR "Example:\n";
        print STDERR "\ttaw mosh foo --region=california -- -l myuser\n";
        exit 0;
    }
    if($subcommand =~ m|^scp$|i) {
        print STDERR "Usage: taw scp <src> <dest> [options...] [-- options for scp]\n\n";
        print STDERR "Example:\n";
        print STDERR "\ttaw scp local.dir awsnodename:/home/ec2user/ -- -r\n";
        print STDERR "\ttaw scp awsnodename:/home/ec2user/test.conf ./\n";
        exit 0;
    }
    if($subcommand =~ m|^setdns$|i) {
        print STDERR "Usage: taw setdns <name> <full domain name> [-- options for cli53]\n";
        print STDERR "       taw setdns <IP address> <full domain name> [-- options for cli53]\n\n";
        print STDERR "Example:\n";
        print STDERR "\ttaw setdns nginxinstance www.example.com -- --ttl 3600 --weight 10 --replace\n";
        exit 0;
    }
    if($subcommand =~ m|^images$|i) {
        print STDERR "Usage: taw images\n\n";
        print STDERR "Options:\n";
        print STDERR "\tNone available\n";
        exit 0;
    }
    if($subcommand =~ m|^show$|i) {
        print STDERR "Usage: taw show <type>\n\n";
        print STDERR "The types include 'region', 'key', 'quickimage', 'instancetype'.\n";
        print STDERR "Options:\n";
        print STDERR "\tNone available\n";
        exit 0;
    }
    if($subcommand =~ m|^fw$|i) {
        print STDERR "Usage: taw fw add <name (or ID)> tcp <port> <cidr>\n";
        print STDERR "       taw fw add <name (or ID)> udp <port> <cidr>\n";
        print STDERR "       taw fw add <name (or ID)> icmp <cidr>\n";
        print STDERR "       taw fw remove <name (or ID)> tcp <port> <cidr>\n";
        print STDERR "       taw fw remove <name (or ID)> udp <port> <cidr>\n";
        print STDERR "       taw fw remove <name (or ID)> icmp <cidr>\n";
        print STDERR "Options:\n";
        print STDERR "\tNone available\n";
        print_valid_cidr_examples();
        exit 0;
    }
    if($subcommand =~ m|^update$|i) {
        print STDERR "Usage: taw update  <update target>\n\n";
        print STDERR "Valid update targets are:\n";
        print STDERR "\tcache\tImage (AMI names) cache\n";
        exit 0;
    }
    print STDERR "Unknown Subcommand '$subcommand'.\n";
    print STDERR "Type 'taw help' to list the available subcommands.\n";
    exit 0;
}

sub cmd_update(@)
{
    my @subcmds = @_;
    print STDERR "CMD_UPDATE\n" if($debug);
    my $subsubcmd = shift(@subcmds);
    if($subsubcmd =~ m|^cache$|i) {
        cmd_cache_image();
        exit 0;
    } elsif(defined $subsubcmd) {
        print STDERR "Unknown update target '$subsubcmd'\n";
        exit 1;
    } else {
        print STDERR "Usage: taw update <update target>\n";
        print STDERR "'taw help update' for details.\n";
        exit 0;
    }
}

sub cmd_list($)
{
    my $list_target = shift;
    $list_target = 'instance' unless(defined $list_target);
    print STDERR "CMD_LIST '$list_target'\n" if($debug);
    if($list_target =~ m|^i(n(s(t(ances?)?)?)?)?$|) {
        my $cmd = "aws ec2 describe-instances";
        my @awscli_result = exec_and_return_array($cmd, "awscli had an error");
        my $tmpfile = save_to_tmp_file_and_return_file_name(@awscli_result);
        print "TMPFILE: $tmpfile\n" if($debug);
        my $ncmd = "cat $tmpfile | jq -c 'if (.Reservations | length != 0) then .Reservations[].Instances[] | " .
                   "{id: .InstanceId, state: .State.Name, pubip: .PublicIpAddress, name: .Tags[] | select(.Key==\"Name\").Value, " .
                   "key: .KeyName, type: .InstanceType, reason: .StateReason.Message, az: .Placement.AvailabilityZone, " .
                   "sg: .SecurityGroups[0].GroupName, subnet: .SubnetId, vpc: .VpcId" .
                   "} else {noinstance: \"No instances\"} end'";
        exec_and_print_in_format($ncmd, "jq/json2csv/csvlook had an error.", [qw(id state name type az sg)], [qw(id state name pubip key type az reason sg)]);
        unlink($tmpfile) unless($debug_leave_file);
    } elsif($list_target =~ m|^v(pc?)?$|i) {
        my $ncmd = "aws ec2 describe-vpcs | jq -c '.Vpcs[]'";
        exec_and_print_in_format($ncmd, "cannot list VPCs", [qw(VpcId State CidrBlock IsDefault)], undef);
    } elsif($list_target =~ m|^s(ub(n(ets?)?)?)?$|i) {
        my $ncmd = "aws ec2 describe-subnets | jq -c '.Subnets[]'";
        exec_and_print_in_format($ncmd, "cannot list subnets", [qw(SubnetId VpcId CidrBlock State)], undef);
    } else {
        print STDERR "Unknown target '$list_target'\n";
        exit 1;
    }
    exit 0;
}

sub exec_and_print_in_format($$$$)
{
    my ($command_line, $message_on_error, $columns_to_show, $columns_to_show_with_verbose_option) = @_;
    my @columns_to_show;
    if($flag_verbose) {
        @columns_to_show = @{$columns_to_show_with_verbose_option} if(defined $columns_to_show_with_verbose_option);
    } else {
        @columns_to_show = @{$columns_to_show} if(defined $columns_to_show);
    }
    if($flag_output_csv || $flag_output_pretty) {
        ensure_command('csvlook') if($flag_output_pretty);
        $command_line .= "| json2csv";
        $command_line .= " -z NotFound";
        if(0 < @columns_to_show) {
            $command_line .= " -c " . join(',', @columns_to_show);
        }
        $command_line .= " -n" if($flag_no_header);
        $command_line .= " | csvlook" if($flag_output_pretty);
        $command_line .= " -H" if($flag_output_pretty && $flag_no_header);
    } elsif($flag_output_json) {
        $command_line .= " | jq -c '{";
        $command_line .= join(', ', map {"\"$_\": .$_"} @columns_to_show);
        $command_line .= "}'";
    }
    exec_and_exit_if_error($command_line, $message_on_error);
}

sub cmd_create(@)
{
    my $subcmd = shift;
    # NOTE: we don't allow fluctuation in the subcmd string.
    #       any create command usually costs more money,
    #       so we need to take an extra caution for safety.
    if($subcmd eq 'instance') {
        my $hostname = shift;
        my $image_id = shift;
        my $keyname = shift;
        my $subnet_id = shift;
        my $securitygroup = shift;
        create_new_instance($hostname, $image_id, $keyname, $subnet_id, $securitygroup);
    } elsif($subcmd eq 'vpc') {
        my $cidr = shift;
        unless(is_valid_cidr($cidr)) {
            print STDERR "'$cidr' doesn't look like a valid CIDR.\n";
            print STDERR "e.g.: 10.0.0.0/16\n";
            exit 1;
        }
        unless(is_valid_private_cidr($cidr)) {
            print STDERR "'$cidr' doesn't look like a private IP address range.\n";
            print STDERR "Private IP ranges are:\n";
            print STDERR "\t192.168.0.0 - 192.168.255.255\n";
            print STDERR "\t172.16.0.0 - 172.31.255.255\n";
            print STDERR "\t10.0.0.0 - 10.255.255.255\n";
            exit 1;
        }
        my $ncmd = "aws ec2 create-vpc --cidr-block $cidr | jq -c .Vpc";
        exec_and_print_in_format($ncmd, "Cannot create a new VPC block", undef, undef);
    } else {
        print STDERR "Unknown target '$subcmd'\n";
        exit 1;
    }
    exit 0;
}

sub get_instance_id_from_name($)
{
    my $name = shift;
    my $cmd = "aws ec2 describe-instances";
    my @awscli_result = exec_and_return_array($cmd, "awscli had an error");
    my $tmpfile = save_to_tmp_file_and_return_file_name(@awscli_result);
    my $ncmd = "cat $tmpfile | jq -c 'if (.Reservations | length != 0) then .Reservations[].Instances[] | {id: .InstanceId, state: .State.Name, pubdns: .PublicDnsName, pubip: .PublicIpAddress, keyname: .KeyName, name: .Tags[] | select(.Key==\"Name\").Value, root: ((.Tags[] | select(.Key == \"root\").Value) // \"\")} else {noinstance: \"No instances\"} end'";
    my @jq_result = exec_and_return_array($ncmd, "jq had an error.");
    unlink($tmpfile) unless($debug_leave_file);
    error_if_jq_result_is_too_small(@jq_result);
    my $first_line_json_obj = decode_json($jq_result[0]);
    if(exists $first_line_json_obj->{"noinstance"}) {
        print STDERR "ERROR: no instances available in the region.\n";
        print STDERR "       Probably you specified a wrong region?\n";
        exit 1;
    }
    for my $json_string (@jq_result) {
        my $json_obj = decode_json($json_string);
        print STDERR "Matching '$name' with $json_obj->{'name'} ...\n" if($debug);
        if($json_obj->{'name'} eq $name) {
            return $json_obj;
        }
    }
    return undef;
}

sub get_security_group_id_from_name($)
{
    my $group_or_id = shift;
    my $cmd = "aws ec2 describe-security-groups";
    my @awscli_result = exec_and_return_array($cmd, "awscli had an error");
    my $tmpfile = save_to_tmp_file_and_return_file_name(@awscli_result);
    print "TMPFILE: $tmpfile\n" if($debug);
    my $ncmd = "cat $tmpfile | jq -c '.SecurityGroups[] | select(.GroupName==\"$group_or_id\" or .GroupId==\"$group_or_id\") | .GroupId // \"noinstance\"'";
    my @jq_result = exec_and_return_array($ncmd, "jq had an error.");
    unlink($tmpfile) unless($debug_leave_file);
    error_if_jq_result_is_too_small(@jq_result);
    my $result = $jq_result[0]; chomp $result;
    return undef if($result eq 'noinstance');
    return $result;
}

sub cmd_ssh($$)
{
    print STDERR "CMD_SSH\n" if($debug);
    my ($name, $ssh_cmd_name) = @_;
    unless(defined $name) {
        print STDERR "ERROR: taw $ssh_cmd_name to where?\n";
        print STDERR "       Type 'taw help $ssh_cmd_name' for help.\n";
        exit 1;
    }
    if($debug) {
        print STDERR "SSH($ssh_cmd_name) to $name\n";
        print STDERR "Arguments are:\n\t";
        print STDERR join("\n\t", @ARGV), "\n";
    }
    my $instance_json = get_instance_id_from_name($name);
    unless(defined $instance_json) {
        print STDERR "ERROR: No such instance (name '$name') available\n";
        exit 1;
    }
    print "SSH to $instance_json->{pubip}\n";
    print "DEBUG: ", encode_json($instance_json), "\n" if($debug);
    my $root_account = $instance_json->{root}; $root_account = "ec2-user" if($root_account eq '');
    my $cmd = "$ssh_cmd_name $instance_json->{pubip} -l $root_account ";
    {
        my $key_file = $ENV{'HOME'} . "/.ssh/" . $instance_json->{keyname} . ".pem";
        print STDERR "Try key file : $key_file\n" if($debug);
        if(-e $key_file) {
            $cmd .= "-i $key_file ";
        }
    }
    $cmd .= join(' ', @ARGV); # TODO: shell escaping
    print STDERR "CMD: $cmd\n" if($debug);
    system $cmd;
    if($? == 127) {
        # User pushed CTRL+D
    } elsif($? >> 8) {
        my $exit_code = $? >> 8;
        if($exit_code != 255) {
            print STDERR "taw: an error occurred. exit = $exit_code\n";
            exit $exit_code;
        }
    }
    exit 0;
}

sub cmd_mosh($)
{
    print STDERR "CMD_MOSH\n" if($debug);
    my $name = shift;
    unless(defined $name) {
        print STDERR "ERROR: taw mosh to where?\n";
        print STDERR "       Type 'taw help mosh' for help.\n";
        exit 1;
    }
    if($debug) {
        print STDERR "mosh to $name\n";
        print STDERR "Arguments are:\n\t";
        print STDERR join("\n\t", @ARGV), "\n";
    }
    my $instance_json = get_instance_id_from_name($name);
    unless(defined $instance_json) {
        print STDERR "ERROR: No such instance (name '$name') available\n";
        exit 1;
    }
    print "SSH to $instance_json->{pubip}\n";
    print "DEBUG: ", encode_json($instance_json), "\n" if($debug);
    my $root_account = $instance_json->{root}; $root_account = "ec2-user" if($root_account eq '');
    my $cmd = "mosh $instance_json->{pubip} --ssh 'ssh -l $root_account";
    {
        my $key_file = $ENV{'HOME'} . "/.ssh/" . $instance_json->{keyname} . ".pem";
        print STDERR "Try key file : $key_file\n" if($debug);
        if(-e $key_file) {
            $cmd .= " -i $key_file";
        }
    }
    $cmd .= "' ";
    $cmd .= join(' ', @ARGV); # TODO: shell escaping
    print STDERR "CMD: $cmd\n" if($debug);
    system $cmd;
    if($? == 127) {
        # User pushed CTRL+D
    } elsif($? >> 8) {
        print STDERR "taw: an error occurred.\n";
        exit ($? >> 8);
    }
    exit 0;
}

sub cmd_scp($$)
{
    my ($src, $dest) = @_;
    print STDERR "CMD_SCP $src $dest\n" if($debug);
    unless(defined $src && defined $dest) {
        print STDERR "ERROR: taw scp to where?\n";
        print STDERR "       Type 'taw help scp' for help.\n";
        exit 1;
    }
    my $ctca = $src =~ /:/; my $ctcb = $dest =~ /:/;
    unless($ctca ^ $ctcb) {
        print STDERR "ERROR: either of the source or the destination must be remote.\n";
        print STDERR "       Use the normal cp for local copy.\n";
        exit 1;
    }
    if($debug) {
        print STDERR "SCP from $src TO $dest\n";
        print STDERR "Arguments are:\n\t";
        print STDERR join("\n\t", @ARGV), "\n";
    }
    my $key_name;
    if($src =~ m|^(.*?):(.*)$|) {
        my ($name, $path) = ($1, $2);
        my $instance_json = get_instance_id_from_name($name);
        unless(defined $instance_json) {
            print STDERR "ERROR: No such instance (name '$name') available\n";
            exit 1;
        }
        print "SCP SRC $instance_json->{pubip}\n";
        print "DEBUG: ", encode_json($instance_json), "\n" if($debug);
        my $root_account = $instance_json->{root}; $root_account = "ec2-user" if($root_account eq '');
        $src = "$root_account\@$instance_json->{pubip}:$path";
        $key_name = $instance_json->{keyname};
    }
    if($dest =~ m|^(.*?):(.*)$|) {
        my ($name, $path) = ($1, $2);
        my $instance_json = get_instance_id_from_name($name);
        unless(defined $instance_json) {
            print STDERR "ERROR: No such instance (name '$name') available\n";
            exit 1;
        }
        print "SCP DEST $instance_json->{pubip}\n";
        print "DEBUG: ", encode_json($instance_json), "\n" if($debug);
        my $root_account = $instance_json->{root}; $root_account = "ec2-user" if($root_account eq '');
        $dest = "$root_account\@$instance_json->{pubip}:$path";
        $key_name = $instance_json->{keyname};
    }
    my $cmd = "scp ";
    {
        my $key_file = $ENV{'HOME'} . "/.ssh/" . $key_name . ".pem";
        print STDERR "Try key file : $key_file\n" if($debug);
        if(-e $key_file) {
            $cmd .= "-i $key_file ";
        }
    }
    $cmd .= join(' ', @ARGV); # TODO: shell escaping
    $cmd .= " $src $dest";
    print STDERR "CMD: $cmd\n" if($debug);
    system $cmd;
    if($? == 127) {
        # User pushed CTRL+D
    } elsif($? >> 8) {
        print STDERR "taw scp: an error occurred.\n";
        exit ($? >> 8);
    }
    exit 0;
}

sub error_if_jq_result_is_too_small(@)
{
    my @jq_result = @_;
    if(@jq_result < 1) {
        print STDERR "ERROR: jq ended unexpectedly (please report it to the author).\n";
        if($debug) {
            print STDERR "jq results:\nSTARTHERE\n";
            print STDERR join("\n", @jq_result), "\nENDHERE\n";
        } else {
            print STDERR "       It might be helpful to rerun the command with --debug and include the results in the report.\n";
        }
        exit 1;
    }
}

sub cmd_images()
{
    print STDERR "CMD_IMAGES\n" if($debug);
    my $cmd = "aws ec2 describe-images --owners=self | jq -c '.Images[]'";
    exec_and_print_in_format($cmd, "Cannot retrieve the image info", [qw(ImageId Name State Architecture RootDeviceType Description)], undef);
    exit 0;
}

sub cmd_setdns($$)
{
    print STDERR "CMD_SETDNS\n" if($debug);
    ensure_command("cli53");
    my ($name, $domain) = @_;
    unless(defined $name) {
        print STDERR "ERROR: taw setdns for which instance?\n";
        print STDERR "       Type 'taw help setdns' for help.\n";
        exit 1;
    }
    unless($domain =~ m|^([\w\d-]+)\.(.*)$|) {
        print STDERR "ERROR: '$domain' does not look like a domain name\n";
        print STDERR "       Type 'taw help setdns' for help.\n";
        exit 1;
    }
    my $host = $1;
    my $zone_name = $2;
    my $ip;
    if($name =~ m|^(\d+)\.(\d+)\.(\d+)\.(\d+)$|) {
        if($debug) {
            print "'$name' looks like an IP.\n";
        }
        $ip = $name;
    } else {
        if($debug) {
            print "Query the host name '$name'\n";
        }
        my $instance_json = get_instance_id_from_name($name);
        unless(defined $instance_json) {
            print STDERR "ERROR: No such instance (name '$name') available\n";
            exit 1;
        }
        $ip = $instance_json->{'pubip'};
        if($debug) {
            print "HOST: $host\nZONE: $zone_name\nIP: $ip\n";
        }
    }
    my $cmd = "cli53 rrcreate $zone_name $host A $ip " . join(" ", @ARGV);
    exec_and_exit_if_error($cmd, "cli53 error.");
    exit 0;
}

sub create_new_instance($$$$$)
{
    my ($hostname, $image_id, $key_name, $subnet_id, $security_groups) = @_;
    print STDERR "CMD_CREATE_INSTANCE\n" if($debug);
    unless(defined $hostname) {
        print STDERR "ERROR: You must give a hostname.\n";
        exit 1;
    }
    unless(defined $image_id) {
        print STDERR "ERROR: You must give an image ID.\n";
        exit 1;
    }
    unless(defined $key_name) {
        print STDERR "ERROR: You must give a (SSH) key name.\n";
        exit 1;
    }
    unless(defined $security_groups) {
        print STDERR "ERROR: You must give security groups. 'default' cannot be omitted even if you leave it to the default.\n";
        exit 1;
    }
    my $cmd = "aws ec2 run-instances --image-id $image_id --min-count 1 --max-count 1 --key-name $key_name --security-groups $security_groups";
    print "CMD: $cmd\n";
    my $ncmd = "aws ec2 craete-tags --resource instance_id --tags '{\"key\": \"Name\", \"value\": \"$hostname\"}'";
    print "NCMD: $ncmd\n";
    exit 0;
}

sub cmd_fw(@)
{
    my $subcmd = shift;
    my @rest_args = @_;
    unless(defined $subcmd) { $subcmd = 'list'; }
    print STDERR "CMD_FW '$subcmd' [" . join(', ', @rest_args) . "]\n" if($debug);
    if($subcmd eq 'list') {
        my $group_or_id = shift;
        my $cmd = "aws ec2 describe-security-groups | jq -c ";
        if(defined $group_or_id) {
            $cmd .= "'.SecurityGroups[] | select(.GroupName==\"$group_or_id\" or .GroupId==\"$group_or_id\") | .IpPermissions[] | " .
                    "{Prot: .IpProtocol, Port: (if .FromPort == .ToPort then .FromPort | tostring else [.FromPort,.ToPort] | " .
                    "map(tostring) | join(\"-\") end), Ranges: .IpRanges | map(.CidrIp) | join(\",\")}'";
            exec_and_print_in_format($cmd, "Failed to list security groups", [qw(Prot Port Ranges)], undef);
        } else {
            $cmd .= "'.SecurityGroups[] | {ID: .GroupId, Name: .GroupName, Desc: .Description, Permission: .IpPermissions} '";
            exec_and_print_in_format($cmd, "Failed to list security groups", [qw(ID Name Desc)], undef);
        }
    } elsif($subcmd eq 'add' || $subcmd eq 'remove') {
        print STDERR "taw fw $subcmd\n" if($debug);
        my $gr_name = shift(@rest_args);
        my $prot = shift(@rest_args);
        my $port = "-1";
        if($prot eq 'tcp' || $prot eq 'udp') {
            $port = shift(@rest_args);
        }
        my $cidr = shift(@rest_args);
        if($prot =~ m{^(tcp|udp|icmp)$}i) {
            $cidr = normalize_cidr($cidr);
            unless(defined $cidr) {
                print STDERR "Invalid CIDR '$cidr'\n";
                print_valid_cidr_examples();
                exit 1;
            }
            my $group_ip = get_security_group_id_from_name($gr_name);
            my $cmd;
            if($subcmd eq 'add') {
                $cmd = "aws ec2 authorize-security-group-ingress --group-id $group_ip --protocol $prot --port $port --cidr $cidr";
            } else {
                $cmd = "aws ec2 revoke-security-group-ingress --group-id $group_ip --protocol $prot --port $port --cidr $cidr";
            }
            exec_and_exit_if_error($cmd, "aws error.");
        } else {
            print STDERR "usage: taw fw add <security group name (or ID)> <prot (tcp/udp/icmp)> <port (omit when icmp)> <cidr> \n";
        }
    } else {
        print STDERR "Unkown subcommand $subcmd\n";
        exit 1;
    }
    exit 0;
}

sub print_valid_cidr_examples()
{
    print STDERR "Valid examples are:\n";
    print STDERR "\t123.45.67.89\n";
    print STDERR "\t123.45.67.0/24\n";
    print STDERR "\t123.45.0.0/16\n";
    print STDERR "\t0.0.0.0/0\n";
    print STDERR "\tany\n";
}

sub exec_and_exit_if_error($$)
{
    my ($cmd, $errormsg) = @_;
    print STDERR "CMD: $cmd\n" if($debug);
    system $cmd;
    if($?) {
        print STDERR "ERROR: " . $errormsg . "\n";
        exit ($? >> 8);
    }
    return 0;
}

sub exec_and_return_array($$)
{
    my ($cmd, $errormsg) = @_;
    print STDERR "CMD: $cmd\n" if($debug);
    my @arr = `$cmd`;
    if($?) {
        print STDERR "ERROR: " . $errormsg . "\n";
        print STDERR join("\n", @arr), "\n";
        exit ($? >> 8);
    }
    return @arr;
}

sub is_region_name_sane($)
{
    my $param_region = shift;
    for my $region (keys %region_name_2_region_str) {
        return 1 if($param_region eq $region);
    }
    return 0;
}

sub convert_region_nick_name($)
{
    my $nickname = shift;
    while(my ($k, $v) = each %region_name_2_region_str) {
        return $k if($nickname =~ m|^$v$|);
    }
    return $nickname;
}

sub cmd_show($)
{
    my $type = shift;
    if($type =~ /^regions?$/i) {
        print "Region\tNickname\n";
        for my $region (sort (keys %region_name_2_region_str)) {
            print $region, "\t", $region_name_2_region_str{$region}, "\n";
        }
    } elsif($type =~ /^keys?$/i) {
        my $key_dir = $ENV{'HOME'} . "/.ssh";
        my @files = <$key_dir/*.pem>;
        for my $i (@files) {
            $i =~ s|.*/||;
            $i =~ s|\.pem$||;
            print "$i\n";
        }
    } elsif($type =~ /^quickimages?/i) {
        my $my_region_name = get_effective_region_name();
        exec_and_exit_if_error("csvgrep -c 4 -m $my_region_name ~/.aws/images.csv | csvlook", "Cannot open ~/.aws/images.csv");
    } elsif($type =~ /^instancetypes?/i) {
        open my $fh, "| csvlook" or die "Cannot execute csvlook";
        print $fh "Instance Name,VCPUs,Memory,Description\n";
        for my $instance_name(sort(keys %instance_type_name_2_instance_type)) {
            my $obj = $instance_type_name_2_instance_type{$instance_name};
            print $fh "$instance_name,$obj->{vcpu},$obj->{mem},\"$obj->{desc}\"\n";
        }
        close $fh;
    } else {
        if(defined $type) {
            print STDERR "Unknown data type '$type'\n";
        } else {
            print STDERR "You need to specify the data type.\n";
        }
        print STDERR "'taw help show' for more details.\n";
        exit 1;
    }
    exit 0;
}

sub get_effective_region_name()
{
    unless(defined $param_region) {
        if(defined $ENV{'AWS_DEFAULT_REGION'}) {
            return $ENV{'AWS_DEFAULT_REGION'};
        } else {
            return 'default';
        }
    }
    return $param_region;
}

sub get_image_info_cache_file_name()
{
    return $ENV{'HOME'} . "/.aws/.image-cache." . get_effective_region_name() . ".json";
}

sub cmd_cache_image()
{
    my $image_info_cache_file_name = get_image_info_cache_file_name();
    print "DEBUG: cache file is '$image_info_cache_file_name'\n" if($debug);
    my $cmd = 'aws ec2 describe-images --owners';
    for my $owner_name (@trusted_ami_owners) {
        $cmd .= " $owner_name";
    }
    $cmd .= ' --filters';
    $cmd .= ' "Name=architecture,Values=x86_64"';     # you don't need i386 on cloud, right?
    $cmd .= ' "Name=image-type,Values=machine"';      # if you need something other than machines, I guess you can use awscli directly.
    $cmd .= ' "Name=virtualization-type,Values=hvm"'; # paravirtualization is old, so again we hardcode hvm here.
    $cmd .= " | jq '.Images | map(select(.Platform != \"windows\"))'"; # doesn't need Windows in academia (at least in biology).
    $cmd .= " > $image_info_cache_file_name.new";
    exec_and_exit_if_error($cmd, "Failed to retrieve AMI info");
    rename("$image_info_cache_file_name.new", $image_info_cache_file_name);
    print "Success.\n";
}

sub ensure_command($)
{
    my $command = shift;
    my $p = `which $command`; chomp $p;
    unless(-x $p) {
        print STDERR "ERROR: $command is not available.\n";
        print STDERR "       Please make sure that $command is on PATH.\n";
        print STDERR "       Ask your system administrator if this message does not make sense to you.\n";
        exit 1;
    }
}

sub save_to_tmp_file_and_return_file_name(@)
{
    my @arr = @_;
    my ($fh, $filename) = tempfile();
    print "TMPFILE: $filename\n" if($debug);
    for(@arr) {
        print $fh $_;
    }
    close $fh;
    return $filename;
}

sub is_valid_private_cidr($)
{
    my $cstr = shift;
    return undef unless($cstr =~ m|^(\d+).(\d+).(\d+).(\d+)/(\d+)$|);
    my ($a1, $a2, $a3, $a4, $nb) = ($1, $2, $3, $4, $5);
    return undef unless(0 <= $a1 && $a1 <= 255);
    return undef unless(0 <= $a2 && $a2 <= 255);
    return undef unless(0 <= $a3 && $a3 <= 255);
    return undef unless(0 <= $a4 && $a4 <= 255);
    return undef unless(0 <= $nb && $nb <= 32);
    if($a1 == 192 && $a2 == 168) {
        return 16 <= $nb;
    }
    if($a1 == 172 && 16 <= $a2 && $a2 <= 31) {
        return 12 <= $nb;
    }
    if($a1 == 10) {
        return 8 <= $nb;
    }
    return undef;
}

sub is_valid_cidr($)
{
    my $cstr = shift;
    return $cstr =~ m|^(\d+).(\d+).(\d+).(\d+)/(\d+)$|;
}

sub normalize_cidr($)
{
    my $cstr = shift;
    if($cstr =~ m|^(\d+)\.(\d+).(\d+).(\d+)/(\d+)$|) {
        return $cstr;
    }
    if($cstr =~ m|^(\d+)\.(\d+).(\d+).(\d+)$|) {
        return $cstr . "/32";
    }
    if($cstr =~ m{^(all|any)$}i) {
        return "0.0.0.0/0";
    }
    return undef;
}

__END__

=head1 NAME

taw - Tiny Amazon EC2 Wrapper

=head1 SYNOPSIS

taw E<lt>commandE<gt> [options...] [arguments...]

Options:

=head1 COMMANDS

=over 8

=item B<taw help>

'taw help' shows how to invoke taw subcommands.
'taw help subcmd' shows how to use a taw subcommand. For example, 'taw help list' shows how to use 'taw list' subcommand.

=item B<taw list>

Show various information. The first argument of B<taw list> is a listing target, for which a user wants to know.
If the listing target is omitted, instances are shown.
See the following items for each target.

=item B<taw list instance>
B<taw list instance> will list instances. To output in CSV, give B<-csv>. When B<-csv> is given, B<-n> suppresses the header line. B<-json> is given, it outputs in JSON. B<-pretty> is given, it outputs in human-friendly table format.

=item B<taw ssh>

SSH to the specified machine. For example, when you type 'taw ssh foo', taw will search the instance with name (tag) 'foo', and ssh to that instance.
The default user is 'ec2-user'. You can set the user name by 'taw ssh foo -- -l user_name'. If you set 'root' tag to an instance, the value of 'root' tag is used as the default user name.

=item B<taw rssh>

rssh to the specified machine. 'taw rssh' is almost the same to 'taw ssh' but it uses rssh instead of ssh.

=item B<taw scp>

Copy files using scp. You can use an AWS machine name instead of FQDN of the remote host.

=item B<taw mosh>

Almost same to B<taw ssh>, but it uses mosh instead of SSH. mosh must be installed on the remote side.

=item B<taw fw>

This subcommand needs a subsubcommand. B<taw fw list> lists the currently available security groups.
B<taw fw add> adds a new rule to a specified security group.
B<taw fw remove> adds a new rule to a specified security group.
See B<taw help fw> for examples.

=item B<taw setdns>

Use Amazon Route 53 to associate a domain name to a specified instance.
For example, 'taw setdns hoge www.example.com -- --ttl 3600 --weight 10 --replace' will set an A-record so that www.example.com will point to an instance with name hoge. Options that come after '--' will be passed through to cli53.

=item B<taw show>

Show the list of a specified type of infomation.
The difference between B<taw list> and B<taw show> is that B<taw show> displays information without querying to Amazon EC2.

For example, B<taw show regions> will show the list of available regions (and their nicknames) in Amazon EC2, which is hardcoded in the B<taw> script..
You can use the nickname of a region name (of Amazon EC2) instead of the region name itself for B<--region> option (e.g., --region=tokyo is equivalent to --rewgion=ap-northeast-1)

B<taw show keys> will show the list of available SSH keys on your computer. It will search only "~/.ssh/*.pem".

B<taw show quickimage> will show the list of quick images. Quick images are defined in "~/.aws/images.csv".
It must contains the following columns in this order; Name,ImageId,Description,Region.
Name is used to specify a particular image (instead of directly specifying ImageId).
Please make sure that Region matches to a region in which you want to create a new instance. Here is an example::

    Name,ImageId,Description,Region
    Amazon20160303,ami-374db956,"Amazon Linux AMI 2016.03.3 (HVM), SSD Volume Type",ap-northeast-1
    RHEL72,ami-0dd8f963,"Red Hat Enterprise Linux 7.2 (HVM), SSD Volume Type",ap-northeast-1
    Ubuntu14,ami-a21529cc,"Ubuntu Server 14.04 LTS (HVM), SSD Volume Type",ap-northeast-1

B<taw show instancetypes> will show the list of available instance types on AWS.
The list shown here does not mean that the displayed instance types are avalilable on the region you use.
The list is hardcoded in the script.

=item B<taw create>

Create something such as instances, VPCs, subnets, etc.
See the following items for details of each command.

=item B<taw create instance>
B<taw create instance> creates a new instance.

=item B<taw images>

Show the list of (private) images of mine in Amazon EC2.

=back

=head1 COMMON OPTIONS

=over 8

=item B<--region>
Specify a region (of Amazon EC2) to work with.

=item B<--debug>
Enable a debug mode.

=item B<--leave>
When the debug mode is enabled, giving this option will leave temporary files that contain the result JSON files from Amazon EC2.
This might help debugging.

=item B<--verbose>
When combined with some subcommands such as list, it will output more items.

=item B<--help>
Show a help message.

=item B<--man>
Show the man page of B<taw>.

=back

=head1 DESCRIPTION

B<taw>, Tiny Amazon ec2 Wrapper, 

=head1 HOW TO INSTALL

B<taw> requires Amazon Commandline Interface (Python version). You have to setup and configure Amazon Command Line Tool first.
Type 'sudo pip install awscli' or 'sudo easy_install awscli' to install Amazon Commandline Interface.

B<taw> also requires jq (http://stedolan.github.io/jq/) and csvkit (https://github.com/onyxfish/csvkit).
As of writing, csvkit in PyPI does not work (cannot be installed because of incorrect dependency declaration in the package), so we recommend you to masnually install csvkit from the HEAD in GitHub (git clone && sudo python setup.py).

B<taw> setdns subcommand uses B<cli53> (https://github.com/barnybug/cli53).

B<taw> depends on JSON module, so please install it (Usually, this is done by 'sudo cpan install JSON').

B<taw> also requires SSH keys to be placed under "~/.ssh". If you generage a key pair on AWS and you download it, copy the pem file to "~/.ssh/".

=head1 LICENSE

B<taw> is distributed under the 2-clause BSD license (http://opensource.org/licenses/BSD-2-Clause).

=head1 AUTHOR

Masahiro Kasahara <masahiro at kasahara.ws>

=cut

